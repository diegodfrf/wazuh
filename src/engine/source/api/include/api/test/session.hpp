#ifndef _API_TEST_SESSION_HPP
#define _API_TEST_SESSION_HPP

#include <condition_variable>
#include <ctime>
#include <memory>
#include <mutex>
#include <string>
#include <unordered_map>
#include <list>

namespace api::sessionManager
{

class TraceStorage
{
public:
    using TraceList = std::vector<std::string>;
    struct AssetData
    {
        TraceList traces;
        bool success = false; ///< False if the asset has failed
    };

    using DataPair = std::pair<std::string, AssetData>;
    using DataList = std::list<DataPair>;

private:
    DataList m_dataList;
    std::unordered_map<std::string, DataList::iterator> m_dataMap;

public:
    TraceStorage()
        : m_dataList()
        , m_dataMap()
    {
    }

    void ingest(const std::string& asset, const std::string& traceContent, bool result)
    {
        if (traceContent.empty())
        {
            return;
        }

        // Try inserting the asset into the map.
        auto [it, inserted] = m_dataMap.try_emplace(asset, m_dataList.end());

        // If is new, insert it into the list.
        if (inserted)
        {
            m_dataList.emplace_back(asset, AssetData {});
            it->second = std::prev(m_dataList.end());
        }

        auto& data = it->second->second;

        if (traceContent == "SUCCESS")
        {
            data.success = true;
        }
        else
        {
            data.traces.push_back(traceContent);
        }
    }

    void clearData()
    {
        m_dataList.clear();
        m_dataMap.clear();
    }

    const DataList& getDataList() const { return m_dataList; }
};

/**
 * @brief Structure for synchronizing and storing output trace data.
 *
 * This struct is used to synchronize and store data related to output trace and session description.
 * It provides synchronization mechanisms to ensure that the data is ready for safe access and updates.
 */
struct OutputTraceDataSync
{

    std::string m_output; ///< Output generated by the asset's events in string format.
    TraceStorage m_traceStorage; ///< Trace storage

    // Synchronization
    std::mutex m_sync;                ///< Mutex for synchronizing access to the data in this struct.
    std::condition_variable m_cvData; ///< Condition variable for signaling data readiness.
    bool m_processedData;             ///< Flag indicating if the data is ready for access.
    bool m_hasTimedout;               ///< Flag indicating if a timeout has occurred while waiting for data.
    std::atomic<bool> m_sessionVisit; ///< Atomic flag for indicating if a session is being visited
};

/**
 * @brief Session class.
 *
 */
class Session
{
public:
    Session(const std::string& sessionName,
            const std::string& policyName,
            const std::string& filterName,
            const std::string& routeName,
            const uint32_t sessionID,
            const uint32_t lifespan,
            const std::string& description,
            const std::time_t creationDate)
        : m_creationDate(creationDate)
        , m_description(description)
        , m_filterName(filterName)
        , m_lifespan(lifespan)
        , m_policyName(policyName)
        , m_routeName(routeName)
        , m_sessionID(sessionID)
        , m_sessionName(sessionName)
    {
        m_spOutputTraceDataSync = std::make_shared<OutputTraceDataSync>();
        m_spOutputTraceDataSync->m_processedData = false;
        m_spOutputTraceDataSync->m_sessionVisit = false;
        m_spOutputTraceDataSync->m_hasTimedout = false;
    }

    /**
     * @brief Get the session description.
     *
     * @return std::string
     */
    std::string getDescription() const { return m_description; };

    /**
     * @brief Get the filter name.
     *
     * @return std::string
     */
    std::string getFilterName() const { return m_filterName; };

    /**
     * @brief Get the policy name.
     *
     * @return std::string
     */
    std::string getPolicyName() const { return m_policyName; };

    /**
     * @brief Get the route name.
     *
     * @return std::string
     */
    std::string getRouteName() const { return m_routeName; };

    /**
     * @brief Get the session ID.
     *
     * @return uint32_t
     */
    uint32_t getSessionID() const { return m_sessionID; };

    /**
     * @brief Get the session name.
     *
     * @return std::string
     */
    std::string getSessionName() const { return m_sessionName; };

    /**
     * @brief Get the session creation date.
     *
     * @todo Consider using modern C++ features like std::chrono instead of std::time_t.
     *
     * @return std::time_t
     */
    std::time_t getCreationDate() const { return m_creationDate; };

    /**
     * @brief Get the session lifespan.
     *
     * @return uint32_t
     */
    uint32_t getLifespan() const { return m_lifespan; };

    /**
     * @brief Get the Data Sync object
     *
     * @return std::shared_ptr<OutputTraceDataSync>
     */
    std::shared_ptr<OutputTraceDataSync> getDataSync() const { return m_spOutputTraceDataSync; };

private:
    const std::string m_description;  ///< Session description.
    const std::string m_filterName;   ///< Filter name.
    const std::string m_policyName;   ///< Policy name.
    const std::string m_routeName;    ///< Route name.
    const std::string m_sessionName;  ///< Session name.
    const std::time_t m_creationDate; ///< Session creation date.
    const uint32_t m_lifespan;        ///< Session m_lifespan in minutes. 0 means no expiration.
    const uint32_t m_sessionID;       ///< Session ID.
    std::shared_ptr<OutputTraceDataSync> m_spOutputTraceDataSync; ///< Output and trace data.
};

} // namespace api::sessionManager

#endif // _API_TEST_SESSION_HPP
